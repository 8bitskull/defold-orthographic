go.property("near_z", -1)
go.property("far_z", 1)
go.property("projection", hash("FIXED"))
go.property("enabled", true)

local camera = require "orthographic.camera"

local DISPLAY_WIDTH = tonumber(sys.get_config("display.width"))
local DISPLAY_HEIGHT = tonumber(sys.get_config("display.height"))

local ENABLE = hash("enable")
local DISABLE = hash("disable")
local UNFOLLOW = hash("unfollow")
local FOLLOW = hash("follow")
local SHAKE = hash("shake")
local DEADZONE = hash("deadzone")
local UPDATE_VIEW_PROJECTION = hash("update_view_projection")


function init(self)
	camera.init(go.get_id())
end


function final(self)
	camera.final(go.get_id())
end


function update(self, dt)
	if self.enabled then
		camera.update(go.get_id(), dt)
		
		-- update view projection after all game objects have been updated
		-- will jitter otherwise
		msg.post("#", UPDATE_VIEW_PROJECTION)
	end
end


function on_message(self, message_id, message, sender)
	if message_id == UPDATE_VIEW_PROJECTION then
		camera.send_view_projection(go.get_id())
	elseif message_id == ENABLE then
		print("enable")
		self.enabled = true
	elseif message_id == DISABLE then
		print("disable")
		self.enabled = false
	elseif message_id == UNFOLLOW then
		print("unfollow")
		camera.unfollow(go.get_id())
	elseif message_id == FOLLOW then
		print("follow", message.lerp and "lerp" or "basic")
		camera.follow(go.get_id(), message.target, message.lerp)
	elseif message_id == DEADZONE then
		print("deadzone")
		camera.deadzone(go.get_id(), message.left, message.right, message.bottom, message.top)
	elseif message_id == SHAKE then
		print("shake")
		camera.shake(go.get_id(), message.intensity, message.duration, message.direction, function()
			msg.post(sender, "shake_completed")
		end)
	end
end